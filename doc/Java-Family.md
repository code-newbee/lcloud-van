# 集合
## HashMap
    1、HashMap的底层数据结构？
    java7：数组 + 链表数据结构
    java8：数组 + 链表 + 红黑树数据结构
    链表的存在是为了解决哈希冲突，哈希算法（将任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法）。
    哈希冲突的插入，Java8以前是头插法，Java8以后是尾插法，修改的原因是解决扩容时链表导致的死循环问题。
    
    2、HashMap的扩容机制？
    HashMap的默认初始化长度时16（位与运算实现均匀分布），负载因子为0.75。当元素长度大于负载因子之后，就会触发扩容。
    扩容的步骤：创建一个2倍长度的空数组 -> 遍历原数组元素进行rehash到新数组中。
    使用头插法在扩容时会改变链表的顺序，尾插法会保证链表的顺序。
    
    3、HashMap为什么说时线程不安全？
    主要原因出在put操作函数中，多线程环境下，同时put两个hash值相同的元素。先判断是否碰撞，然后写入值。如果线程A过了判断还未写入值，此时挂起，线程B也会通过判断并写值，此时线程A就会覆盖线程B已经写入的值。
    
    4、怎么解决HashMap线程不安全的问题？
    - Collections.synchronized(map):内部维护了一个普通map，和一个排它锁对象。操作map时会对所有方法上锁。
    - HashTable：所有方法直接使用synchronized。
    HashTable不允许null的存在，但是HashMap允许。Hashtable的遍历使用安全失败机制，HashMap时快速失败机制。区别在于遍历时前者会复制原集合进行遍历，后者遍历原集合，维护一个标志位count，如果遍历的过程中其它线程对原集合进行修改，则会抛出异常。
    - ConcurrentHashMap
    segment数组，HashEntry组成。
    java7：分段锁，先定位到segment，put时自旋锁，get时valilate属性。
    java8：CAS + synchronized。
    CAS：读取数据时不加锁，写回数据时再次读取和原数据比较。添加版本号解决ABA问题。
    
    

    
    
    
    
    
    